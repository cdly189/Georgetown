---
title: "Portfolio Optimization"
author: "Phillip Monin"
#date: 
output: html_document
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

## Get data

First we load packages

```{r}
library(tidyverse)
library(tidyquant) # for downloading data
library(plotly) # interactive graphics
library(timetk)
```

We select the following stocks for our portfolios:

* Apple Inc (AAPL)
* Amazon (AMZN)
* Netflix (NFLX)
* Exxon Mobil (XOM)
* AT&T (T)

Download price data:

```{r}
tickers <- c('AAPL','AMZN','NFLX','XOM','T')

price_data <- tq_get(tickers,
                     from = '2017-01-01',
                     to = '2021-12-31',
                     get = 'stock.prices')

head(price_data)

```

Compute continuously compounded daily returns:

```{r}
log_ret <- price_data %>%
  group_by(symbol) %>%
  tq_transmute(select = adjusted,
               mutate_fun = periodReturn,
               period = 'daily',
               col_rename = 'ret',
               type = 'log')

head(log_ret)
```

Convert this long frame to wide using `spread()` and make into a time series object using `xts()`:

```{r}
log_ret_xts <- log_ret %>%
  spread(symbol, value = ret) %>%
  tk_xts()

head(log_ret_xts)
```

Compute mean daily and annual returns:

```{r}
mean_ret <- colMeans(log_ret_xts)
mean_ret_ann <- 252 * mean_ret
print(round(mean_ret_ann, 3))
```

Compute covariance matrix, which we have also annualized:
```{r}
cov_mat <- 252 * cov(log_ret_xts)
print(round(cov_mat, 3))
```


Compute correlation matrix, which is perhaps easier to interpret:

```{r}
corr_mat <- cor(log_ret_xts)
print(round(corr_mat, 3))
```


Next, we simulate many random portfolios. The randomness is generated by randomly sampling portfolio weights, which must sum to 1.

We first show how it works for a single random portfolio, and then we will loop it.

```{r}
wts <- runif(n = length(tickers))
wts <- wts / sum(wts)
print(wts)
```

Next, calculate the (annualized) portfolio returns:
```{r}
port_returns <- sum(wts * mean_ret_ann)
print(port_returns)
```

Next, calculate the portfolio's *volatlity*, which is the standard deviation of the returns

```{r}
port_vol <- sqrt(t(wts) %*% (cov_mat %*% wts))
print(round(port_vol, 3))
```

Next, calculate the Sharpe ratio (assuming risk-free rate of 0%)

```{r}
sharpe_ratio <- (port_returns - 0) / port_vol
print(round(sharpe_ratio, 3))
```

Now, we will do this simulation several times in a loop:

```{r}
num_port <- 5000

# Create matrix to store all weights
all_wts <- matrix(nrow = num_port,
                  ncol = length(tickers))

# Create vector to store portfolio returns, portfolio volatilities, and Sharpe ratios
port_returns <- vector('numeric', length = num_port)
port_vols <- vector('numeric', length = num_port)
sharpe_ratios <- vector('numeric', length = num_port)
```

Next run the loop:

```{r}
for (i in seq_along(port_returns)){
  
  wts <- runif(length(tickers))
  wts <- wts/sum(wts)
  
  all_wts[i,] <- wts
  
  port_ret <- sum(wts * mean_ret_ann)
  port_returns[i] <- port_ret
  
  port_vol <- sqrt(t(wts) %*% (cov_mat %*% wts))
  port_vols[i] <- port_vol

  sharpe_ratio <- (port_ret - 0) / port_vol 
  sharpe_ratios[i] <- sharpe_ratio
  
}
```

Now create frames to hold the values:

```{r}
portfolio_values <- tibble(Return = port_returns,
                           Volatility = port_vols,
                           SharpeRatio = sharpe_ratios)

# Convert matrix of weights to tibble and change column names
all_wts <- tk_tbl(all_wts)
colnames(all_wts) <- colnames(log_ret_xts)

# Combine 
portfolio_values <- tk_tbl(cbind(all_wts, portfolio_values))

head(portfolio_values)
```

We now have the weights in each asset along with the portfolio's return, volatility, and Sharpe ratio.

Let's look at some portfolios of interest from the theory, namely the minimum variance portfolio and the tangency portfolio (the one with the highest Sharpe ratio):

```{r}
min_var_port <- portfolio_values[which.min(portfolio_values$Volatility),]
tangency_port <- portfolio_values[which.max(portfolio_values$SharpeRatio),]
```

Let's plot the weights of each portfolio. First, the minimum variance portfolio:

```{r}
p <- min_var_port %>%
  gather(AAPL:XOM, key = Asset, value = Weights) %>%
  mutate(Asset = as.factor(Asset)) %>%
  ggplot(aes(x = fct_reorder(Asset,Weights), y = Weights, fill = Asset)) + 
  geom_bar(stat = 'identity') + 
  theme_minimal() + 
  labs(x = 'Assets', y = 'Weights', title = 'Minimum Variance Portfolio Weights') +
  scale_y_continuous(labels = scales::percent)

ggplotly(p)
```

And now the tangency portfolio, the one with the highest Sharpe ratio:

```{r}
p <- tangency_port %>%
  gather(AAPL:XOM, key = Asset, value = Weights) %>%
  mutate(Asset = as.factor(Asset)) %>%
  ggplot(aes(x = fct_reorder(Asset,Weights), y = Weights, fill = Asset)) + 
  geom_bar(stat = 'identity') + 
  theme_minimal() + 
  labs(x = 'Assets', y = 'Weights', title = 'Tangency Portfolio Weights') +
  scale_y_continuous(labels = scales::percent)

ggplotly(p)
```

Let's plot all portfolios and visualize the efficient frontier

```{r}
p <- portfolio_values %>%
  ggplot(aes(x = Volatility, y = Return, color=SharpeRatio)) +
  geom_point(size=0.4) + 
  theme_classic() +
  scale_y_continuous(labels = scales::percent) + 
  scale_x_continuous(labels = scales::percent) +
  labs(x="Annualized Volatility", y="Annualized Returns", title="Efficient Frontier") + 
  geom_point(aes(x=Volatility, y=Return), data=min_var_port, color='red', size=0.6) + 
  geom_point(aes(x=Volatility, y=Return), data=tangency_port, color='red', size=0.6)
  #annotate('text', x=0.20, y=0.42, label='Tangency Portfolio') + 
  #annotate('text', x=0.18, y=0.01, label='Minimum variance portfolio') + 
  #annotate(geom = 'segment', x=0.22, xend=0.2275, y=0.405, yend=0.365, color='red', arrow=arrow(type='open')) +
  #annotate(geom = 'segment', x=0.14, xend=0.1350, y=0.010, yend=0.060, color='red', arrow=arrow(type='open'))

ggplotly(p)
```

## Solving for the Efficient Frontier

First, we solve for the global minimum variance portfolio $\boldsymbol{m}=(m_1,\dots,m_N)'$ by solving the constrained minimization problem
$$
\min_{\boldsymbol{m}} \sigma^2_{p,m} = \boldsymbol{m}'\boldsymbol{\Sigma} \boldsymbol{m},\qquad \text{such that}\qquad \boldsymbol{m}'\boldsymbol{1}=1
$$
The Lagrangian is
$$
L(\boldsymbol{m},\lambda) = \boldsymbol{m}'\boldsymbol{\Sigma} \boldsymbol{m} + \lambda(\boldsymbol{m}'\boldsymbol{1}-1),
$$
and the first order conditions for a minimum are
$$
0=\frac{\partial L}{\partial \boldsymbol{m}} = 2\boldsymbol{\Sigma} \boldsymbol{m} + \lambda \boldsymbol{1},
$$
and
$$
0=\frac{\partial L}{\partial \lambda} = \boldsymbol{m}'\boldsymbol{1}-1
$$
The first order conditions give $N+1$ linear equations in $N+1$ unknowns. They have matrix representation
$$
\left( \begin{array}{cc} 2\boldsymbol{\Sigma} & \boldsymbol{1} \\ \boldsymbol{1}' & 0 \end{array}\right) \left(\begin{array}{c} \boldsymbol{m} \\ \lambda \end{array}\right) = \left(\begin{array}{c} \boldsymbol{0} \\ 1 \end{array}\right)
$$

Writing this as $\boldsymbol{A_mz_m}=\boldsymbol{b}$, we can solve for $\boldsymbol{z_m}=\boldsymbol{A_m}^{-1}\boldsymbol{b}$ provided that $\boldsymbol{A_m}$ is invertible. The first $N$ elements of $\boldsymbol{z_m}$ is the solution portfolio weight vector $\boldsymbol{m}$ for the global minimum variance portfolio with expected return $\mu_{p,m}=\boldsymbol{m}'\boldsymbol{\mu}$ and variance $\sigma_{p,m}^2=\boldsymbol{m}'\boldsymbol{\Sigma} \boldsymbol{m}$

```{r}
top_row <-  cbind(2*cov_mat, rep(1, length(tickers)))
bot_row <-  c(rep(1, length(tickers)), 0)
Am_mat <-  rbind(top_row, bot_row)
b_vec <-  c(rep(0, length(tickers)), 1)
zm_mat <-  solve(Am_mat)%*%b_vec
m_vec <-  zm_mat[1:length(tickers),1]
print(m_vec)
```

The mean of the minimum variance portfolio is

```{r}
mu_min_var <-  sum(m_vec * mean_ret_ann)
sigma_min_var <-  sqrt(as.numeric(t(m_vec) %*% (cov_mat %*% m_vec)))
print(c(mu_min_var, sigma_min_var))

```

Next, we compute an efficient portfolio $\boldsymbol{x}$ with target expected return equal to the maximum expected return of the assets, $mu_0=\max\{\mu_1,\dots,\mu_N\}$. Here we solve
$$
\min_{\boldsymbol{x}} \sigma^2_{p,x}=\boldsymbol{x}'\boldsymbol{\Sigma} \boldsymbol{x},\quad \text{such that}\quad \mu_0=\boldsymbol{x}'\boldsymbol{\mu},\quad \boldsymbol{x}'\boldsymbol{1}=1
$$
The Lagrangian is
$$
L(\boldsymbol{x},\lambda_1,\lambda_2) = \boldsymbol{x}'\boldsymbol{\Sigma} \boldsymbol{x} + \lambda_1(\boldsymbol{x}'\boldsymbol{\mu}-\mu_0) + \lambda_2(\boldsymbol{x}'\boldsymbol{1}-1)
$$

The first order conditions are
$$
0=\frac{\partial L}{\partial \boldsymbol{x}}=2\boldsymbol{\Sigma} \boldsymbol{x}+\lambda_1\boldsymbol{\mu}+\lambda_2\boldsymbol{1}
$$
$$
0=\frac{\partial L}{\partial \lambda_1} = \boldsymbol{x}'\boldsymbol{\mu}-\mu_0
$$
$$
0 = \frac{\partial L}{\partial\lambda_2} = \boldsymbol{x}'\boldsymbol{1}-1
$$
These first order conditions consist of $N+2$ linear equations in $N+2$ unknowns, $(\boldsymbol{x},\lambda_1,\lambda_2)$. In matrix algebra this is
$$
\left( \begin{array}{ccc} 2\boldsymbol{\Sigma} & \boldsymbol{\mu} & 1 \\ \boldsymbol{\mu}' & 0 & 0 \\ \boldsymbol{1}' & 0 & 0\end{array}\right) \left(\begin{array}{c} \boldsymbol{x} \\ \lambda_1 \\ \lambda_2 \end{array}\right)=\left(\begin{array}{c} \boldsymbol{0} \\ \mu_0 \\ 1 \end{array}\right) 
$$
which is of the form $\boldsymbol{Az}=\boldsymbol{b}$. Provided $\boldsymbol{A}$ is invertible, the solution is $\boldsymbol{z}=\boldsymbol{A}^{-1}\boldsymbol{b}$. The first $N$ elements of $\boldsymbol{z}$ are the portfolio weights for the minimum variance portfolio with expected return $\mu_0$. If $\mu_0$ is greater than or equal to the return on the minimum variance portfolio, then $\boldsymbol{x}$ is an efficient portfolio; otherwise, $\boldsymbol{x}$ is inefficient.

```{r}
max_mean <-  max(mean_ret_ann) #tangency_port$Return

top_mat <- cbind(2*cov_mat, mean_ret_ann, rep(1, length(tickers)))
mid_vec <- c(mean_ret_ann, 0, 0)
bot_vec <- c(rep(1, length(tickers)), 0, 0)
A_mat <- rbind(top_mat, mid_vec, bot_vec)

b_vec <- c(rep(0, length(tickers)), max_mean, 1)

z_mat <- solve(A_mat)%*%b_vec
x_vec <- z_mat[1:length(tickers),]
print(x_vec)
```

The mean and volatility of $\boldsymbol{x}$ are
```{r}
mu_x <- sum(x_vec * mean_ret_ann)

sigma_x <- sqrt(as.numeric(t(x_vec) %*% (cov_mat %*% x_vec)))

print(c(mu_x, sigma_x))

if (mu_x >= mu_min_var){
  print("x is efficient!")
} else {
  print("Bad news! x is inefficient!")
}
```

Next, we compute the covariance of the minimum variance portfolio $\boldsymbol{m}$ and the efficient portfolio $\boldsymbol{x}$:
```{r}
sigma_mx <- t(m_vec) %*% (cov_mat %*% x_vec)
print(sigma_mx)
```

We use the two-fund theorem to trace out the efficient frontier:
```{r}
a <- seq(from=0, to=1, by=0.005)
n_a <- length(a)
z_mat <- matrix(0, n_a, length(tickers))
colnames(z_mat) <- names(mean_ret_ann)
mu_z <- rep(0, n_a)
sigma2_z <- rep(0, n_a)
sigma_mx <- t(m_vec) %*% (cov_mat %*% x_vec)

for (i in 1:n_a){
  z_mat[i,] <- a[i]*x_vec + (1-a[i])*m_vec
  mu_z[i] <- a[i]*mu_x + (1-a[i])*mu_min_var
  sigma2_z[i] <- a[i]^2 * sigma_x^2 + 2*a[i]*(1-a[i])*sigma_mx + (1-a[i])^2 * sigma_min_var^2
}
```

Finally, we plot it with our previous efficient frontier
```{r}
eff_front <- data.frame(mu_z, sqrt(sigma2_z))
colnames(eff_front) <- c("Return","Volatility")
```

```{r}
p <- portfolio_values %>%
  ggplot(aes(x = Volatility, y = Return, color=SharpeRatio)) +
  geom_point(size=0.4) + 
  theme_classic() +
  scale_y_continuous(labels = scales::percent) + 
  scale_x_continuous(labels = scales::percent) +
  labs(x="Annualized Volatility", y="Annualized Returns", title="Efficient Frontier") + 
  geom_point(aes(x=Volatility, y=Return), data=min_var_port, color='red', size=0.6) + 
  geom_point(aes(x=Volatility, y=Return), data=tangency_port, color='red', size=0.6) +
  #annotate('text', x=0.20, y=0.42, label='Tangency Portfolio') + 
  #annotate('text', x=0.18, y=0.01, label='Minimum variance portfolio') + 
  #annotate(geom = 'segment', x=0.22, xend=0.2275, y=0.405, yend=0.365, color='red', arrow=arrow(type='open')) +
  #annotate(geom = 'segment', x=0.14, xend=0.1350, y=0.010, yend=0.060, color='red', arrow=arrow(type='open'))
  geom_point(aes(x=Volatility, y=Return), data=eff_front, color='black', size=0.6)

ggplotly(p)
```

